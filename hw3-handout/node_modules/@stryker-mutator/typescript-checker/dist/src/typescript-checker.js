"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypescriptChecker = exports.create = void 0;
const tslib_1 = require("tslib");
const os_1 = require("os");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const typescript_1 = (0, tslib_1.__importDefault)(require("typescript"));
const check_1 = require("@stryker-mutator/api/check");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const fs_1 = require("./fs");
const tsconfig_helpers_1 = require("./tsconfig-helpers");
const pluginTokens = (0, tslib_1.__importStar)(require("./plugin-tokens"));
const diagnosticsHost = {
    getCanonicalFileName: (fileName) => fileName,
    getCurrentDirectory: process.cwd,
    getNewLine: () => os_1.EOL,
};
const FILE_CHANGE_DETECTED_DIAGNOSTIC_CODE = 6032;
typescriptCheckerLoggerFactory.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.getLogger, plugin_1.commonTokens.target);
// eslint-disable-next-line @typescript-eslint/ban-types
function typescriptCheckerLoggerFactory(loggerFactory, target) {
    var _a;
    const targetName = (_a = target === null || target === void 0 ? void 0 : target.name) !== null && _a !== void 0 ? _a : TypescriptChecker.name;
    const category = targetName === TypescriptChecker.name ? TypescriptChecker.name : `${TypescriptChecker.name}.${targetName}`;
    return loggerFactory(category);
}
create.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.injector);
function create(injector) {
    return injector
        .provideFactory(plugin_1.commonTokens.logger, typescriptCheckerLoggerFactory, plugin_1.Scope.Transient)
        .provideClass(pluginTokens.fs, fs_1.HybridFileSystem)
        .injectClass(TypescriptChecker);
}
exports.create = create;
/**
 * An in-memory type checker implementation which validates type errors of mutants.
 */
class TypescriptChecker {
    constructor(logger, options, fs) {
        this.logger = logger;
        this.fs = fs;
        this.currentTask = new util_1.Task();
        this.currentErrors = [];
        this.logDiagnostic = (label) => {
            return (d) => {
                this.logger.trace(`${label} ${typescript_1.default.formatDiagnostics([d], diagnosticsHost)}`);
            };
        };
        this.tsconfigFile = (0, tsconfig_helpers_1.toPosixFileName)(options.tsconfigFile);
        this.allTSConfigFiles = new Set([path_1.default.resolve(this.tsconfigFile)]);
    }
    /**
     * Starts the typescript compiler and does a dry run
     */
    async init() {
        (0, tsconfig_helpers_1.guardTSVersion)();
        this.guardTSConfigFileExists();
        this.currentTask = new util_1.Task();
        const buildModeEnabled = (0, tsconfig_helpers_1.determineBuildModeEnabled)(this.tsconfigFile);
        const compiler = typescript_1.default.createSolutionBuilderWithWatch(typescript_1.default.createSolutionBuilderWithWatchHost({
            ...typescript_1.default.sys,
            readFile: (fileName) => {
                var _a;
                const content = (_a = this.fs.getFile(fileName)) === null || _a === void 0 ? void 0 : _a.content;
                if (content && this.allTSConfigFiles.has(path_1.default.resolve(fileName))) {
                    return this.adjustTSConfigFile(fileName, content, buildModeEnabled);
                }
                return content;
            },
            watchFile: (filePath, callback) => {
                this.fs.watchFile(filePath, callback);
                return {
                    close: () => {
                        delete this.fs.getFile(filePath).watcher;
                    },
                };
            },
            writeFile: (filePath, data) => {
                this.fs.writeFile(filePath, data);
            },
            createDirectory: () => {
                // Idle, no need to create directories in the hybrid fs
            },
            clearScreen() {
                // idle, never clear the screen
            },
            getModifiedTime: (fileName) => {
                return this.fs.getFile(fileName).modifiedTime;
            },
            watchDirectory: () => {
                // this is used to see if new files are added to a directory. Can safely be ignored for mutation testing.
                return {
                    // eslint-disable-next-line @typescript-eslint/no-empty-function
                    close() { },
                };
            },
        }, undefined, (error) => this.currentErrors.push(error), (status) => this.logDiagnostic('status')(status), (summary) => {
            this.logDiagnostic('summary')(summary);
            summary.code !== FILE_CHANGE_DETECTED_DIAGNOSTIC_CODE && this.resolveCheckResult();
        }), [this.tsconfigFile], {});
        compiler.build();
        const result = await this.currentTask.promise;
        if (result.status === check_1.CheckStatus.CompileError) {
            throw new Error(`TypeScript error(s) found in dry run compilation: ${result.reason}`);
        }
    }
    guardTSConfigFileExists() {
        if (!typescript_1.default.sys.fileExists(this.tsconfigFile)) {
            throw new Error(`The tsconfig file does not exist at: "${path_1.default.resolve(this.tsconfigFile)}". Please configure the tsconfig file in your stryker.conf file using "${(0, util_1.propertyPath)('tsconfigFile')}"`);
        }
    }
    /**
     * Checks whether or not a mutant results in a compile error.
     * Will simply pass through if the file mutated isn't part of the typescript project
     * @param mutant The mutant to check
     */
    async check(mutant) {
        if (this.fs.existsInMemory(mutant.fileName)) {
            this.clearCheckState();
            this.fs.mutate(mutant);
            return this.currentTask.promise;
        }
        else {
            // We allow people to mutate files that are not included in this ts project
            return {
                status: check_1.CheckStatus.Passed,
            };
        }
    }
    /**
     * Post processes the content of a tsconfig file. Adjusts some options for speed and alters quality options.
     * @param fileName The tsconfig file name
     * @param content The tsconfig content
     * @param buildModeEnabled Whether or not `--build` mode is used
     */
    adjustTSConfigFile(fileName, content, buildModeEnabled) {
        const parsedConfig = typescript_1.default.parseConfigFileTextToJson(fileName, content);
        if (parsedConfig.error) {
            return content; // let the ts compiler deal with this error
        }
        else {
            for (const referencedProject of (0, tsconfig_helpers_1.retrieveReferencedProjects)(parsedConfig, path_1.default.dirname(fileName))) {
                this.allTSConfigFiles.add(referencedProject);
            }
            return (0, tsconfig_helpers_1.overrideOptions)(parsedConfig, buildModeEnabled);
        }
    }
    /**
     * Resolves the task that is currently running. Will report back the check result.
     */
    resolveCheckResult() {
        if (this.currentErrors.length) {
            const errorText = typescript_1.default.formatDiagnostics(this.currentErrors, {
                getCanonicalFileName: (fileName) => fileName,
                getCurrentDirectory: process.cwd,
                getNewLine: () => os_1.EOL,
            });
            this.currentTask.resolve({
                status: check_1.CheckStatus.CompileError,
                reason: errorText,
            });
        }
        this.currentTask.resolve({ status: check_1.CheckStatus.Passed });
    }
    /**
     * Clear state between checks
     */
    clearCheckState() {
        while (this.currentErrors.pop()) {
            // Idle
        }
        this.currentTask = new util_1.Task();
    }
}
exports.TypescriptChecker = TypescriptChecker;
TypescriptChecker.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, pluginTokens.fs);
//# sourceMappingURL=typescript-checker.js.map