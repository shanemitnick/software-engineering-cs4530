"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPosixFileName = exports.retrieveReferencedProjects = exports.overrideOptions = exports.determineBuildModeEnabled = exports.guardTSVersion = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const typescript_1 = (0, tslib_1.__importDefault)(require("typescript"));
const semver_1 = (0, tslib_1.__importDefault)(require("semver"));
// Override some compiler options that have to do with code quality. When mutating, we're not interested in the resulting code quality
// See https://github.com/stryker-mutator/stryker-js/issues/391 for more info
const COMPILER_OPTIONS_OVERRIDES = Object.freeze({
    allowUnreachableCode: true,
    noUnusedLocals: false,
    noUnusedParameters: false,
});
// When we're running in 'single-project' mode, we can safely disable emit
const NO_EMIT_OPTIONS_FOR_SINGLE_PROJECT = Object.freeze({
    noEmit: true,
    incremental: false,
    composite: false,
    declaration: false,
    declarationMap: false,
});
// When we're running in 'project references' mode, we need to enable declaration output
const LOW_EMIT_OPTIONS_FOR_PROJECT_REFERENCES = Object.freeze({
    emitDeclarationOnly: true,
    noEmit: false,
    declarationMap: false,
});
function guardTSVersion() {
    if (!semver_1.default.satisfies(typescript_1.default.version, '>=3.6')) {
        throw new Error(`@stryker-mutator/typescript-checker only supports typescript@3.6 our higher. Found typescript@${typescript_1.default.version}`);
    }
}
exports.guardTSVersion = guardTSVersion;
/**
 * Determines whether or not to use `--build` mode based on "references" being there in the config file
 * @param tsconfigFileName The tsconfig file to parse
 */
function determineBuildModeEnabled(tsconfigFileName) {
    const tsconfigFile = typescript_1.default.sys.readFile(tsconfigFileName);
    if (!tsconfigFile) {
        throw new Error(`File "${tsconfigFileName}" not found!`);
    }
    const useProjectReferences = 'references' in typescript_1.default.parseConfigFileTextToJson(tsconfigFileName, tsconfigFile).config;
    return useProjectReferences;
}
exports.determineBuildModeEnabled = determineBuildModeEnabled;
/**
 * Overrides some options to speed up compilation and disable some code quality checks we don't want during mutation testing
 * @param parsedConfig The parsed config file
 * @param useBuildMode whether or not `--build` mode is used
 */
function overrideOptions(parsedConfig, useBuildMode) {
    var _a;
    const compilerOptions = {
        ...(_a = parsedConfig.config) === null || _a === void 0 ? void 0 : _a.compilerOptions,
        ...COMPILER_OPTIONS_OVERRIDES,
        ...(useBuildMode ? LOW_EMIT_OPTIONS_FOR_PROJECT_REFERENCES : NO_EMIT_OPTIONS_FOR_SINGLE_PROJECT),
    };
    if (!useBuildMode && compilerOptions.declarationDir !== undefined && compilerOptions.declarationDir !== null) {
        // because composite and/or declaration was disabled in non-build mode, we have to disable declarationDir as well
        // otherwise, error TS5069: Option 'declarationDir' cannot be specified without specifying option 'declaration' or option 'composite'.
        delete compilerOptions.declarationDir;
    }
    return JSON.stringify({
        ...parsedConfig.config,
        compilerOptions,
    });
}
exports.overrideOptions = overrideOptions;
/**
 * Retrieves the referenced config files based on parsed configuration
 * @param parsedConfig The parsed config file
 * @param fromDirName The directory where to resolve from
 */
function retrieveReferencedProjects(parsedConfig, fromDirName) {
    var _a, _b;
    if (Array.isArray((_a = parsedConfig.config) === null || _a === void 0 ? void 0 : _a.references)) {
        return (_b = parsedConfig.config) === null || _b === void 0 ? void 0 : _b.references.map((reference) => path_1.default.resolve(fromDirName, typescript_1.default.resolveProjectReferencePath(reference)));
    }
    return [];
}
exports.retrieveReferencedProjects = retrieveReferencedProjects;
/**
 * Replaces backslashes with forward slashes (used by typescript)
 * @param fileName The file name that may contain backslashes `\`
 * @returns posix and ts complaint file name (with `/`)
 */
function toPosixFileName(fileName) {
    return fileName.replace(/\\/g, '/');
}
exports.toPosixFileName = toPosixFileName;
//# sourceMappingURL=tsconfig-helpers.js.map